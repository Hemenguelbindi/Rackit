use crate::cli::args::{Commands, OutputFormat, ExampleTemplate};
use crate::config_engine::{load_config, create_executor, create_example_config};
use crate::config_engine::types::StepType;
use crate::error::Result;

/// –í—ã–ø–æ–ª–Ω—è–µ—Ç CLI –∫–æ–º–∞–Ω–¥—É
pub fn execute_command(command: Commands, verbose: u8, quiet: bool) -> Result<()> {
    match command {
        Commands::Run { 
            config, device, scenario, dry_run, parallel, max_parallel, ignore_errors 
        } => {
            cmd_run(config, device, scenario, dry_run, parallel, max_parallel, ignore_errors, verbose, quiet)
        }
        Commands::Validate { config, strict } => {
            cmd_validate(config, strict, verbose, quiet)
        }
        Commands::Plan { config, device, scenario, detailed } => {
            cmd_plan(config, device, scenario, detailed, verbose, quiet)
        }
        Commands::List { config, devices, scenarios, format } => {
            cmd_list(config, devices, scenarios, format, verbose, quiet)
        }
        Commands::Example { output, template, force } => {
            cmd_example(output, template, force, verbose, quiet)
        }
        Commands::Check { config, device, ping_only, timeout } => {
            cmd_check(config, device, ping_only, timeout, verbose, quiet)
        }
        Commands::Shell { config, device, command } => {
            cmd_shell(config, device, command, verbose, quiet)
        }
    }
}

/// rackit run config.toml
fn cmd_run(
    config_path: std::path::PathBuf,
    device_filter: Option<String>,
    scenario_filter: Option<String>,
    dry_run: bool,
    parallel: bool,
    _max_parallel: usize,
    ignore_errors: bool,
    verbose: u8,
    quiet: bool,
) -> Result<()> {
    if !quiet {
        println!("üöÄ Rackit - –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏");
        if dry_run {
            println!("üîç –†–µ–∂–∏–º: —Å—É—Ö–æ–π –∑–∞–ø—É—Å–∫ (dry-run)");
        }
        if parallel {
            println!("‚ö° –†–µ–∂–∏–º: –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ");
        }
        println!();
    }

    // –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
    let executor = create_executor(&config_path)?;
    let config = executor.config();

    if verbose > 0 {
        println!("üìñ –ó–∞–≥—Ä—É–∂–µ–Ω–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏–∑: {}", config_path.display());
        println!("   –£—Å—Ç—Ä–æ–π—Å—Ç–≤: {}", config.devices.len());
        println!("   –°—Ü–µ–Ω–∞—Ä–∏–µ–≤: {}", config.scenarios.len());
        println!();
    }

    if dry_run {
        println!("üìã –ü–ª–∞–Ω –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è (dry-run):");
        return cmd_plan(config_path, device_filter, scenario_filter, true, verbose, quiet);
    }

    // –§–∏–ª—å—Ç—Ä—É–µ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
    let devices_to_run: Vec<&String> = if let Some(device_id) = &device_filter {
        if config.devices.contains_key(device_id) {
            vec![device_id]
        } else {
            eprintln!("‚ùå –£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ '{}' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏", device_id);
            return Ok(());
        }
    } else {
        config.devices.keys().collect()
    };

    if !quiet {
        println!("üéØ –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–ª—è {} —É—Å—Ç—Ä–æ–π—Å—Ç–≤:", devices_to_run.len());
        for device_id in &devices_to_run {
            let device_config = &config.devices[*device_id];
            println!("  üì± {} - {} ({})", 
                device_id, 
                device_config.device_info.name,
                device_config.device_info.vendor
            );
        }
        println!();
    }

    // –í—ã–ø–æ–ª–Ω—è–µ–º –∫–æ–º–∞–Ω–¥—ã
    let mut success_count = 0;
    let mut error_count = 0;

    for device_id in devices_to_run {
        if verbose > 0 {
            println!("üîß –û–±—Ä–∞–±–æ—Ç–∫–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞: {}", device_id);
        }

        match executor.execute_device(device_id) {
            Ok(result) => {
                if result.is_success() {
                    success_count += 1;
                    if !quiet {
                        println!("‚úÖ {} - –≤—ã–ø–æ–ª–Ω–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ ({} –∫–æ–º–∞–Ω–¥)", 
                            device_id, result.success_count());
                    }
                } else {
                    error_count += 1;
                    println!("‚ö†Ô∏è {} - –≤—ã–ø–æ–ª–Ω–µ–Ω–æ —Å –æ—à–∏–±–∫–∞–º–∏ ({} —É—Å–ø–µ—à–Ω—ã—Ö, {} –æ—à–∏–±–æ–∫)", 
                        device_id, result.success_count(), result.error_count());
                    
                    if verbose > 0 {
                        for error in &result.failed_commands {
                            println!("   ‚ùå {}: {}", error.command_name, error.error_message);
                        }
                    }
                }
            }
            Err(e) => {
                error_count += 1;
                println!("‚ùå {} - –æ—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: {}", device_id, e);
                
                if !ignore_errors {
                    println!("üí° –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ --ignore-errors –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö");
                    break;
                }
            }
        }
    }

    if !quiet {
        println!();
        println!("üìä –ò—Ç–æ–≥–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è:");
        println!("   ‚úÖ –£—Å–ø–µ—à–Ω–æ: {}", success_count);
        println!("   ‚ùå –° –æ—à–∏–±–∫–∞–º–∏: {}", error_count);
        println!("   üìà –û–±—â–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {}", 
            if error_count == 0 { "‚úÖ –£—Å–ø–µ—Ö" } else { "‚ö†Ô∏è –ï—Å—Ç—å –æ—à–∏–±–∫–∏" }
        );
    }

    Ok(())
}

/// rackit validate config.toml
fn cmd_validate(
    config_path: std::path::PathBuf,
    strict: bool,
    verbose: u8,
    quiet: bool,
) -> Result<()> {
    if !quiet {
        println!("üîç Rackit - –≤–∞–ª–∏–¥–∞—Ü–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏");
        if strict {
            println!("üîí –†–µ–∂–∏–º: —Å—Ç—Ä–æ–≥–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è");
        }
        println!();
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
    if !config_path.exists() {
        eprintln!("‚ùå –§–∞–π–ª –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω: {}", config_path.display());
        return Ok(());
    }

    // –ó–∞–≥—Ä—É–∂–∞–µ–º –∏ –≤–∞–ª–∏–¥–∏—Ä—É–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
    match load_config(&config_path) {
        Ok(config) => {
            if !quiet {
                println!("‚úÖ –°–∏–Ω—Ç–∞–∫—Å–∏—Å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω");
                println!("   üì± –£—Å—Ç—Ä–æ–π—Å—Ç–≤: {}", config.devices.len());
                println!("   üé≠ –°—Ü–µ–Ω–∞—Ä–∏–µ–≤: {}", config.scenarios.len());
            }

            if verbose > 0 {
                println!("\nüìã –î–µ—Ç–∞–ª–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏:");
                for (device_id, device_config) in &config.devices {
                    println!("  üì± {}: {} –∫–æ–º–∞–Ω–¥", device_id, device_config.command_sequence.len());
                }
            }

            if strict {
                println!("\nüîí –°—Ç—Ä–æ–≥–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è (–ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤):");
                println!("‚ö†Ô∏è –°—Ç—Ä–æ–≥–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –ø–æ–∫–∞ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞");
            }

            if !quiet {
                println!("\nüéâ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –≤–∞–ª–∏–¥–Ω–∞!");
            }
        }
        Err(e) => {
            eprintln!("‚ùå –û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏: {}", e);
        }
    }

    Ok(())
}

/// rackit plan config.toml
fn cmd_plan(
    config_path: std::path::PathBuf,
    device_filter: Option<String>,
    _scenario_filter: Option<String>,
    detailed: bool,
    verbose: u8,
    quiet: bool,
) -> Result<()> {
    if !quiet {
        println!("üìã Rackit - –ø–ª–∞–Ω –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è");
        println!();
    }

    let config = load_config(&config_path)?;

    // –§–∏–ª—å—Ç—Ä—É–µ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
    let devices_to_show: Vec<&String> = if let Some(device_id) = &device_filter {
        if config.devices.contains_key(device_id) {
            vec![device_id]
        } else {
            eprintln!("‚ùå –£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ '{}' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ", device_id);
            return Ok(());
        }
    } else {
        config.devices.keys().collect()
    };

    println!("üéØ –ü–ª–∞–Ω –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –¥–ª—è {} —É—Å—Ç—Ä–æ–π—Å—Ç–≤:", devices_to_show.len());
    println!();

    for device_id in devices_to_show {
        let device_config = &config.devices[device_id];
        
        println!("üì± –£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: {} ({})", device_id, device_config.device_info.name);
        println!("   üè≠ –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å: {}", device_config.device_info.vendor);
        println!("   üîó –¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç: {:?} -> {}", 
            device_config.connection.transport, 
            device_config.connection.host
        );
        println!("   üìù –ö–æ–º–∞–Ω–¥ –∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—é: {}", device_config.command_sequence.len());

        if detailed || verbose > 0 {
            println!("   üìã –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∫–æ–º–∞–Ω–¥:");
            for (i, step) in device_config.command_sequence.iter().enumerate() {
                let step_desc = match &step.step_type {
                    StepType::Login => "üîê –í—Ö–æ–¥ –≤ —Å–∏—Å—Ç–µ–º—É".to_string(),
                    StepType::Logout => "üö™ –í—ã—Ö–æ–¥ –∏–∑ —Å–∏—Å—Ç–µ–º—ã".to_string(),
                    StepType::Command { command, .. } => format!("üíª –ö–æ–º–∞–Ω–¥–∞: '{}'", command),
                    StepType::Delay { milliseconds } => format!("‚è±Ô∏è –ü–∞—É–∑–∞: {} –º—Å", milliseconds),
                    StepType::WaitPrompt { prompt } => format!("‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ: '{}'", prompt),
                    StepType::CheckResponse { contains, .. } => format!("‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞: '{}'", contains),
                };
                println!("      {}. {} - {}", i + 1, step.name, step_desc);
            }
        }
        println!();
    }

    if !quiet {
        println!("üí° –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ 'rackit run' –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –ø–ª–∞–Ω–∞");
    }

    Ok(())
}

/// rackit list config.toml
fn cmd_list(
    config_path: std::path::PathBuf,
    devices_only: bool,
    scenarios_only: bool,
    format: OutputFormat,
    _verbose: u8,
    quiet: bool,
) -> Result<()> {
    let config = load_config(&config_path)?;

    match format {
        OutputFormat::Table => {
            if !scenarios_only {
                if !quiet { println!("üì± –£—Å—Ç—Ä–æ–π—Å—Ç–≤–∞:"); }
                println!("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
                println!("‚îÇ ID              ‚îÇ –ù–∞–∑–≤–∞–Ω–∏–µ                ‚îÇ –¢–∏–ø         ‚îÇ –ü—Ä–æ–∏–∑–≤–æ–¥.   ‚îÇ –ö–æ–º–∞–Ω–¥      ‚îÇ");
                println!("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§");
                
                for (device_id, device_config) in &config.devices {
                    println!("‚îÇ {:<15} ‚îÇ {:<23} ‚îÇ {:<11} ‚îÇ {:<11} ‚îÇ {:<11} ‚îÇ",
                        truncate(device_id, 15),
                        truncate(&device_config.device_info.name, 23),
                        format!("{:?}", device_config.device_info.device_type),
                        truncate(&device_config.device_info.vendor, 11),
                        device_config.command_sequence.len()
                    );
                }
                println!("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò");
                println!();
            }

            if !devices_only && !config.scenarios.is_empty() {
                if !quiet { println!("üé≠ –°—Ü–µ–Ω–∞—Ä–∏–∏:"); }
                println!("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
                println!("‚îÇ ID              ‚îÇ –ù–∞–∑–≤–∞–Ω–∏–µ                ‚îÇ –¶–µ–ª–µ–≤—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞      ‚îÇ –ö–æ–º–∞–Ω–¥      ‚îÇ");
                println!("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§");
                
                for (scenario_id, scenario) in &config.scenarios {
                    let target_desc = match &scenario.target_devices {
                        crate::config_engine::types::TargetDevices::All => "–í—Å–µ".to_string(),
                        crate::config_engine::types::TargetDevices::Specific { devices } => {
                            format!("{} —É—Å—Ç—Ä–æ–π—Å—Ç–≤", devices.len())
                        },
                        crate::config_engine::types::TargetDevices::ByType { device_type } => {
                            format!("–¢–∏–ø: {:?}", device_type)
                        },
                        crate::config_engine::types::TargetDevices::ByVendor { vendor } => {
                            format!("–ü—Ä–æ–∏–∑–≤.: {}", vendor)
                        },
                    };
                    
                    println!("‚îÇ {:<15} ‚îÇ {:<23} ‚îÇ {:<23} ‚îÇ {:<11} ‚îÇ",
                        truncate(scenario_id, 15),
                        truncate(&scenario.name, 23),
                        truncate(&target_desc, 23),
                        scenario.commands.len()
                    );
                }
                println!("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò");
            }
        }
        OutputFormat::List => {
            if !scenarios_only {
                for device_id in config.devices.keys() {
                    println!("{}", device_id);
                }
            }
            if !devices_only {
                for scenario_id in config.scenarios.keys() {
                    println!("{}", scenario_id);
                }
            }
        }
        OutputFormat::Json => {
            println!("JSON —Ñ–æ—Ä–º–∞—Ç –ø–æ–∫–∞ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω");
        }
        OutputFormat::Yaml => {
            println!("YAML —Ñ–æ—Ä–º–∞—Ç –ø–æ–∫–∞ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω");
        }
    }

    Ok(())
}

/// rackit example output.toml
fn cmd_example(
    output_path: std::path::PathBuf,
    template: ExampleTemplate,
    force: bool,
    _verbose: u8,
    quiet: bool,
) -> Result<()> {
    if !quiet {
        println!("üìù –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–∏–º–µ—Ä–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏");
        println!("   –®–∞–±–ª–æ–Ω: {:?}", template);
        println!("   –§–∞–π–ª: {}", output_path.display());
        println!();
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
    if output_path.exists() && !force {
        eprintln!("‚ùå –§–∞–π–ª —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç: {}", output_path.display());
        eprintln!("üí° –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ --force –¥–ª—è –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∏");
        return Ok(());
    }

    // –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–º–µ—Ä –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —à–∞–±–ª–æ–Ω–∞
    match template {
        ExampleTemplate::Full => {
            create_example_config(&output_path)?;
        }
        ExampleTemplate::Minimal => {
            let minimal_config = create_minimal_example();
            std::fs::write(&output_path, minimal_config)?;
        }
        ExampleTemplate::Eltex => {
            let eltex_config = create_eltex_example();
            std::fs::write(&output_path, eltex_config)?;
        }
        ExampleTemplate::Cisco => {
            println!("‚ö†Ô∏è Cisco —à–∞–±–ª–æ–Ω –ø–æ–∫–∞ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω, —Å–æ–∑–¥–∞–µ–º –ø–æ–ª–Ω—ã–π –ø—Ä–∏–º–µ—Ä");
            create_example_config(&output_path)?;
        }
        ExampleTemplate::Linux => {
            println!("‚ö†Ô∏è Linux —à–∞–±–ª–æ–Ω –ø–æ–∫–∞ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω, —Å–æ–∑–¥–∞–µ–º –ø–æ–ª–Ω—ã–π –ø—Ä–∏–º–µ—Ä");
            create_example_config(&output_path)?;
        }
    }

    if !quiet {
        println!("‚úÖ –ü—Ä–∏–º–µ—Ä –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ —Å–æ–∑–¥–∞–Ω: {}", output_path.display());
        println!("üí° –û—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π—Ç–µ —Ñ–∞–π–ª –ø–æ–¥ –≤–∞—à–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –∏ –∑–∞–ø—É—Å—Ç–∏—Ç–µ:");
        println!("   rackit validate {}", output_path.display());
        println!("   rackit plan {}", output_path.display());
        println!("   rackit run {}", output_path.display());
    }

    Ok(())
}

/// rackit check config.toml
fn cmd_check(
    config_path: std::path::PathBuf,
    device_filter: Option<String>,
    ping_only: bool,
    _timeout: u64,
    _verbose: u8,
    quiet: bool,
) -> Result<()> {
    if !quiet {
        println!("üîç Rackit - –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤");
        if ping_only {
            println!("üì° –†–µ–∂–∏–º: —Ç–æ–ª—å–∫–æ –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è");
        }
        println!();
    }

    let config = load_config(&config_path)?;

    // –§–∏–ª—å—Ç—Ä—É–µ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
    let devices_to_check: Vec<&String> = if let Some(device_id) = &device_filter {
        if config.devices.contains_key(device_id) {
            vec![device_id]
        } else {
            eprintln!("‚ùå –£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ '{}' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ", device_id);
            return Ok(());
        }
    } else {
        config.devices.keys().collect()
    };

    println!("üéØ –ü—Ä–æ–≤–µ—Ä–∫–∞ {} —É—Å—Ç—Ä–æ–π—Å—Ç–≤:", devices_to_check.len());
    println!();

    for device_id in devices_to_check {
        let device_config = &config.devices[device_id];
        print!("üì± {} ({}) ... ", device_id, device_config.connection.host);
        
        // –ü–æ–∫–∞ —á—Ç–æ –ø—Ä–æ—Å—Ç–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å "–Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ"
        println!("‚ö†Ô∏è –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞");
    }

    Ok(())
}

/// rackit shell config.toml --device router1
fn cmd_shell(
    _config_path: std::path::PathBuf,
    device_id: String,
    command: Option<String>,
    _verbose: u8,
    quiet: bool,
) -> Result<()> {
    if !quiet {
        println!("üñ•Ô∏è Rackit - –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞—è –æ–±–æ–ª–æ—á–∫–∞");
        println!("   –£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: {}", device_id);
        if let Some(cmd) = &command {
            println!("   –ö–æ–º–∞–Ω–¥–∞: {}", cmd);
        } else {
            println!("   –†–µ–∂–∏–º: –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π");
        }
        println!();
    }

    println!("‚ö†Ô∏è –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞—è –æ–±–æ–ª–æ—á–∫–∞ –ø–æ–∫–∞ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞");
    
    Ok(())
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏

fn truncate(s: &str, max_len: usize) -> String {
    if s.len() <= max_len {
        s.to_string()
    } else {
        format!("{}...", &s[..max_len.saturating_sub(3)])
    }
}

fn create_minimal_example() -> String {
    r#"# –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –ø—Ä–∏–º–µ—Ä –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ Rackit

[global_settings]
max_retries = 3
command_delay_ms = 100
default_timeout_seconds = 30

[devices.my_device]
[devices.my_device.device_info]
name = "My Device"
device_type = "router"
model = "Unknown"
vendor = "Unknown"

[devices.my_device.connection]
transport = "serial"
host = "/dev/ttyS0"
baud_rate = 115200

[devices.my_device.credentials]
username = "admin"
password = "password"

[[devices.my_device.command_sequence]]
name = "login"
step_type = { type = "login" }
on_error = "stop"

[[devices.my_device.command_sequence]]
name = "show_info"
step_type = { type = "command", data = { command = "show version" } }
on_error = "continue"
"#.to_string()
}

fn create_eltex_example() -> String {
    r#"# –ü—Ä–∏–º–µ—Ä –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –¥–ª—è Eltex —É—Å—Ç—Ä–æ–π—Å—Ç–≤

[global_settings]
max_retries = 3
command_delay_ms = 200
default_timeout_seconds = 30

[devices.eltex_router]
[devices.eltex_router.device_info]
name = "Eltex ESR-200"
device_type = "router"
model = "ESR-200"
vendor = "Eltex"

[devices.eltex_router.connection]
transport = "serial"
host = "/dev/ttyS0"
baud_rate = 115200
timeout_seconds = 10

[devices.eltex_router.credentials]
username = "admin"
password = "password"

[[devices.eltex_router.command_sequence]]
name = "login"
step_type = { type = "login" }
on_error = "stop"

[[devices.eltex_router.command_sequence]]
name = "show_system"
step_type = { type = "command", data = { command = "show system", expected_prompt = "esr-200#" } }
on_error = "continue"

[[devices.eltex_router.command_sequence]]
name = "show_version"
step_type = { type = "command", data = { command = "show version", expected_prompt = "esr-200#" } }
on_error = "continue"

[[devices.eltex_router.command_sequence]]
name = "logout"
step_type = { type = "logout" }
on_error = "continue"
"#.to_string()
} 